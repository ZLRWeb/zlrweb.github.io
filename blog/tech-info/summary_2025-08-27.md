---
slug: tech-summary-2025-08-26
title: TechSummary 2025-08-26
authors: gemini
tags: [AI, SoftwareDevelopment, Learning, Debugging, CI/CD, Cloud, Database, RAG, IndustrialIoT, InfrastructureAsCode, FeatureFlags, OpenSource, PerformanceBenchmarking, Kotlin, Ruby, Java, iOS]
---

# TechSummary 2025-08-26

## 🤔 重新發掘學習的樂趣：Jason Lengstorf 談開發現況

**Source:** https://github.blog/developer-skills/career-growth/rediscovering-joy-in-learning-jason-lengstorf-on-the-state-of-development/

-   文章探討了開發者對學習新技術的焦慮感，Jason Lengstorf (CodeTV 創始人) 認為學習應該是基於樂趣而非害怕被淘汰。
-   **AI 作為能力乘數而非取代者**：AI 能顯著提升熟練開發者的速度，並加速初學者的學習過程。但若缺乏學習意願，AI 反而會製造更大的問題。
-   **開源維護者的重要性**：文中強調了 SQLite 和 Zod 等關鍵開源專案依賴少數維護者，呼籲開發者社群應支持其使用的「負載承載型」開源專案，例如透過 GitHub Sponsors。
-   **未來網頁創新的趨勢**：JavaScript 生態系目前處於停滯期，而 CSS 則蓬勃發展。Jason 預測 AI 將改變 UX 基礎，使其更具對話性，並結合本地 AI 模型和標準化協議（如 MCP），為獨立開發者帶來類似早期 JavaScript 框架時代的機會。

<!-- truncate -->

## 📚 Kotlin Notebook 如何助你教學程式設計

**Source:** https://blog.jetbrains.com/kotlin/2025/08/how-kotlin-notebook-helps-teach-programming/

-   **互動式學習環境**：Kotlin Notebook 是一款專為程式教學設計的工具，它能在單一互動式環境中結合可執行程式碼、Markdown 文字解釋和視覺化內容。
-   **簡化教學流程**：講師無需在投影片、實時演示和 IDE 之間切換，一個 Notebook 即可完成 Kotlin 程式碼的編寫、解釋和執行。
-   **真實課堂應用**：Constructor University 的 Anastasiia Birillo 講師在課程中運用 Kotlin Notebook，以結構化的章節展示程式碼、即時輸出和解釋，讓學生能親自重跑所有內容，專注於概念而非冗長的程式碼片段。
-   **教學優勢**：
    -   **增量執行**：支援單元格執行，可隔離展示程式碼片段、進行偵錯或逐步教學。
    -   **Markdown + 程式碼**：將不同類型的資料（程式碼、文字解釋、視覺化）整合在同一互動空間。
    -   **簡易設定與分享**：基於 IntelliJ IDEA 的 Kotlin Notebook 插件預設啟用，並可輕鬆透過 GitHub 分享，降低技術門檻。

## ⚙️ 如何為 iOS 專案建立 CI/CD 流水線

**Source:** https://blog.jetbrains.com/teamcity/2025/08/cicd-for-ios/

-   **簡化 iOS 發布流程**：文章詳細說明如何使用 JetBrains TeamCity Cloud 配合 `fastlane` 為 iOS 專案建立端到端的 CI/CD 流水線，以應對程式碼簽章、佈建描述檔、多版本支援及 App Store 規範等複雜挑戰。
-   **CI/CD 階段與 TeamCity 支援**：
    -   **程式碼檢出與版本控制**：與 GitHub 等 VCS 整合，支援自動觸發建置。
    -   **建置 iOS 應用**：使用 `xcodebuild` 或 `fastlane`，支援多種配置及 TeamCity 的 Matrix Build 平行建置。
    -   **跨 iOS 版本測試**：透過 TeamCity 的平行測試功能加速多版本和設備配置的測試。
    -   **靜態程式碼分析**：整合 SwiftLint 等工具，支援 JetBrains Qodana 生成程式碼覆蓋報告。
    -   **簽章與打包 (IPA)**：推薦使用 `fastlane match` 將憑證和描述檔存儲於 Git 或 S3，實現安全且可擴展的程式碼簽章。
    -   **部署至 TestFlight 或 App Store**：`fastlane` 自動化上傳 IPA 至 TestFlight，並可配置不同發布工作流程。
-   **實作步驟**：
    -   **設定 iOS 專案**：使用 `fastlane init` 初始化並設定 `fastlane/Fastfile`，定義 `beta` lane 以自動化建置、遞增版本號碼、打包並上傳至 TestFlight。
        ```ruby
        default_platform(:ios)

        before_all do
          create_keychain(name: "keychain", password: "password", default_keychain: true, unlock: true, timeout: 3600, lock_when_sleeps: false)
          match(type: "appstore", keychain_name: "keychain", keychain_password: "password", readonly: true)
        end

        platform :ios do
          desc "Build and upload to TestFlight"
          lane :beta do |options|
            increment_build_number(xcodeproj: "Facto.xcodeproj")
            build_app(scheme: "Facto", configuration: "Release", export_method: "app-store", export_options: { provisioningProfiles: { "dev.draft.Facto" => "Facto Distribution" } })
            api_key = app_store_connect_api_key(key_id: options[:key_id], issuer_id: options[:issuer_id], key_filepath: File.absolute_path("tmp/AuthKey.p8"), duration: 1200, in_house: false)
            pilot(api_key: api_key, skip_waiting_for_build_processing: true, skip_submission: true)
          end
        end
        ```
    -   **配置 `fastlane match`**：選擇 S3 作為儲存後端，安全地儲存和管理憑證，並將 `Appfile` 中的敏感資訊替換為環境變數。
    -   **TeamCity Cloud 專案建立**：設定專案、選擇 Git 儲存庫，並指定 macOS 14 Sonoma Arm64 作為建置代理。
    -   **設定建置任務腳本**：建立一個腳本步驟，用於設定 AWS 憑證、從 AWS Secrets Manager 下載 App Store Connect API Key，並執行 `fastlane beta` 命令。
        ```bash
        export AWS_ACCESS_KEY_ID=%AWS_ACCESS_KEY_ID%
        export AWS_SECRET_ACCESS_KEY=%AWS_SECRET_ACCESS_KEY%
        export AWS_REGION=%AWS_REGION%

        mkdir -p fastlane/tmp
        aws secretsmanager get-secret-value --secret-id ASC_KEY --output text --query SecretString | base64 -d -o fastlane/tmp/AuthKey.p8

        export KEY_ID=`aws secretsmanager get-secret-value --secret-id ASC_KEY_ID --output text --query 'SecretString' | cut -d '"' -f4`
        # ... (其他敏感變數如 ISSUER_ID, APP_IDENTIFIER 等)

        bundle install
        bundle exec fastlane beta key_id:"$KEY_ID" issuer_id:"$ISSUER_ID"
        ```
    -   **設定 AWS Secrets 與 TeamCity 建置參數**：在 AWS Secrets Manager 中儲存所有敏感資訊，並在 TeamCity 中設定對應的建置參數（如 AWS 存取金鑰和地區）以安全地傳遞給流水線。
-   **結果**：成功觸發建置後，應用程式將被打包、簽章並上傳至 TestFlight，並透過 App Store Connect 發送通知。

## 🐞 揭密 Ruby 除錯器：byebug、debug gem 與 RubyMine 的威力

**Source:** https://blog.jetbrains.com/ruby/2025/08/unveiling-ruby-debuggers-byebug-debug-gem-and-the-power-of-rubymine/

-   **除錯器的重要性**：RubyMine 的匿名使用數據顯示，近三分之一的運行是除錯模式，凸顯了除錯器在專業 Ruby 開發中的關鍵作用。
-   **byebug 的內部機制與限制**：
    -   `byebug` 是一款簡單的 Ruby 除錯器，提供斷點、步進和變數檢查等基本功能。
    -   其核心機制是維護斷點列表，並為每種事件類型（如 `:line` 事件）設定一個 `TracePoint`。當追蹤事件發生時，`byebug` 會檢查該位置是否有斷點。
    -   **性能問題**：這種「每次事件都檢查」的模式導致顯著的性能開銷。即使只有一個斷點，`byebug` 也會檢查每次追蹤事件，導致應用程式運行速度比正常情況慢 20 到 30 倍，對於複雜的 Rails 應用程式不實用。
    ```ruby
    breakpoints = [] # list of breakpoints
    tracepoints = [] # contains a single tracepoint for each event type

    tracepoints << TracePoint.trace(:line) do |tp|
      breakpoint = breakpoints.find do |b|
        tp.path == b.path && tp.lineno == b.lineno
      end
      if breakpoint
        handle_breakpoint(breakpoint)
      end
    end
    # ... ordinal code execution
    ```
-   **debug gem 的性能優化**：
    -   `debug gem` 專為 Ruby 2.7 及更高版本設計，透過 Ruby 2.6 中 `TracePoint` 的改進解決了性能問題。
    -   **目標式 TracePoint**：`debug gem` 為每個斷點建立一個專用的 `TracePoint`，並將其直接綁定到程式碼中對應的位置（特定行或指令序列），只在精確位置執行時觸發，大幅減少了運行時開銷。
    ```ruby
    def say_hello = puts "Hello Ruby developers!"
    def say_goodbye = puts "Goodbye Ruby developers!"

    iseq = RubyVM::InstructionSequence.of(method(:say_hello))
    trace = TracePoint.new(:call) do |tp|
      puts "Calling method '#{tp.method_id}'"
    end

    trace.enable(target: iseq)

    say_hello
    say_goodbye
    # => Calling method 'say_hello'
    # => Hello Ruby developers!
    # => Goodbye Ruby developers!
    ```
    -   從 Ruby 3.1 開始，`debug gem` 被捆綁為預設除錯器。
-   **RubyMine 除錯器的架構與優勢**：
    -   **廣泛的 Ruby 版本支援**：RubyMine 除錯器支援 Ruby 2.3 及更高版本，且在所有版本中均保持優異性能。
    -   **簡化的除錯體驗**：無需修改專案配置或安裝額外插件，即可立即使用所有功能，包括「智慧步進」（Smart Stepping）。
    -   **模組化架構**：
        -   `debase gem` (C 擴展)：核心後端，處理底層操作。
        -   `ruby-debug-ide gem`：內部除錯器前端，管理 RubyMine 與後端的通信。
        -   RubyMine IDE：提供使用者介面和高階除錯功能。
    -   **雙分支設計**：為不同 Ruby 版本維護兩個獨立的除錯器 gem 分支，確保舊版 Ruby 的性能（透過低階技巧）和新版 Ruby 的可維護性（利用現代 API 和改進的 `TracePoint`）。
-   **性能基準測試結果**：
    -   在 Ruby 2.6.10 上，`byebug` 比原始運行慢 30 倍，而 `RubyMine debugger` 沒有明顯性能影響。
    -   在 Ruby 3.4.2 上，`RubyMine debugger` 和 `debug gem` 均表現出色，沒有明顯的性能下降。
    -   **結論**：RubyMine 除錯器在所有 Ruby 版本中均提供一致的高性能；`debug gem` 是現代 Ruby 版本中強大的開源替代方案；`byebug` 由於性能問題不適合複雜應用。
    ```ruby
    def fib(n)
      raise if n < 0 # place a breakpoint on this line
      return n if n < 2
      fib(n - 1) + fib(n - 2)
    end

    require 'benchmark'
    TOTAL_RUNS = 100
    total_time = TOTAL_RUNS.times.sum do
      Benchmark.realtime { fib(40) }
    end

    puts "Avg real time elapsed: #{total_time/TOTAL_RUNS}"
    ```

## 📊 使用 Python 評測儲存性能 (延遲、吞吐量)

**Source:** https://dzone.com/articles/aws-s3-benchmarking-python-latency-throughput

-   **評測目的**：了解 AWS S3 儲存的讀寫速度對於成本優化和應用程式性能至關重要。
-   **Python 腳本應用**：透過運行 Python 腳本來測量延遲（latency）和吞吐量（throughput）。
-   **決策依據**：這些評測結果有助於比較不同的 S3 儲存類別，找出隱藏的瓶頸，並根據數據做出關於資料儲存位置和方式的決策。
-   **目標受眾**：本文旨在簡化 S3 基準測試的概念，即使非雲端基礎設施專家也能理解並解讀結果。

## 🧠 從簡單查詢到智能代理推理：智能 RAG 系統的崛起

**Source:** https://dzone.com/articles/rag-architectures-evolution-simple-to-agentic

-   **RAG (檢索增強生成) 的核心概念**：RAG 是一種大型語言模型 (LLM) 技術，透過在生成過程中整合外部資料檢索，來增強文本生成能力。
-   **克服 LLM 限制**：與僅依賴模型預訓練知識的傳統 LLM 不同，RAG 允許 AI 在生成時「查找」外部來源，從而顯著提高回應的事實準確性和相關性，有效緩解「幻覺」（虛構或不準確的事實）和知識過時的問題。
-   **動態記憶**：本質上，RAG 為 AI 提供了一個超越其靜態訓練資料的動態記憶。
-   **RAG 架構的演進**：RAG 體系結構不斷演進，每個新架構都旨在解決先前方法的具體缺陷，例如維護對話上下文、處理多個數據源和提高檢索相關性。

## 🛡️ 建構 AI 驅動的異常檢測模型以確保工業自動化安全

**Source:** https://dzone.com/articles/ai-anomaly-detection-industrial-iot-security

-   **工業自動化中的安全挑戰**：現代工業自動化系統中，安全性是確保互聯設備正常運行的首要條件。然而，網路風險的增加對工業的可持續運營構成重大威脅，傳統防禦方法已難以應對不斷演變的、更具針對性的網路攻擊。
-   **主動式防禦需求**：面對不斷變化的網路威脅，需要一種主動而非被動的策略。
-   **AI 驅動的異常檢測框架**：文章提出了一個利用人工智慧建構異常檢測框架的用例，具體而言，是一個混合學習模型：
    -   **深度學習 LSTM 模型**：用於特徵提取。
    -   **機器學習分類器**：用於檢測和預測工業自動化中的異常行為。
-   **工業 4.0 的雙面性**：新一代技術（如 5G、大數據分析、物聯網 IoT 和人工智慧 AI）在提供優化操作和高效可持續性的同時，也為網路犯罪分子打開了新的大門，影響工業網路的可持續性和運營。

## 💰 Oracle Standard Edition 與 PostgreSQL (開源)：為注重成本的團隊進行性能基準測試

**Source:** https://dzone.com/articles/oracle-standard-edition-vs-postgresql-open-source-1

-   **資料庫選擇的重要性**：關係型資料庫是幾乎所有應用程式棧的核心，選擇合適的資料庫會影響應用程式性能、可擴展性、維護開銷以及總體擁有成本。
-   **兩大 OLTP 資料庫比較**：
    -   **Oracle Standard Edition (SE)**：在企業界享有盛譽，以其事務完整性、高級並發控制和穩固的耐用性著稱，是金融、醫療保健和製造等需要高可靠性行業的首選。
    -   **PostgreSQL (開源)**：近年來成為開發者新寵，以其性能、可擴展性以及開源許可模式（避免供應商鎖定）而備受推崇。
-   **文章目標**：為注重成本的團隊提供 Oracle SE 和 PostgreSQL 在 OLTP 領域的性能基準測試分析，以幫助他們做出明智的資料庫選擇。

## 🤖 GitHub Copilot 與 Copilot Agent 的比較分析：架構、能力及其對軟體開發的影響

**Source:** https://dzone.com/articles/github-copilot-vs-copilot-agent-ai-coding-tools-compared

-   **AI 在軟體開發中的變革**：人工智慧正迅速重塑軟體開發、測試和維護的方式。
-   **GitHub Copilot**：作為一款智能程式碼助理，它透過學習數十億行公開程式碼，提供即時的程式碼補全建議，引領著這場轉變。
-   **GitHub Copilot Agent**：隨著開發工作複雜性的增加，對超越程式碼補全的 AI 工具需求也隨之產生。Copilot Agent 是一個更自主的助理，它能理解自然語言，遍歷多個專案檔案，並執行更高級的開發任務，例如重構、偵錯和生成單元測試。
-   **比較分析**：本文旨在比較 GitHub Copilot 和 Copilot Agent 的架構、功能和對軟體開發的影響，展示 AI 輔助編碼工具從簡單補全到智能代理推理的演進。

## ☕ Java 21 虛擬執行緒與快取及固定執行緒池的比較

**Source:** https://dzone.com/articles/java-concurrency-evolution-virtual-threads-java21

-   **併發程式設計的重要性**：併發程式設計仍然是構建可擴展、響應迅速的 Java 應用程式的關鍵部分。
-   **Java 併發演進**：本文回顧了 Java 從 8 到 21 版本的併發演進，重點介紹了重要的改進和 Java 21 中虛擬執行緒 (Virtual Threads) 的引入。
-   **Java 8 的增強功能**：Java 8 的併發 API 獲得顯著增強，例如原子變數 (Atomic Variables)、併發映射 (Concurrent Maps) 以及 lambda 表達式的整合，以實現更具表達力的並行程式設計。
-   **Java 21 虛擬執行緒**：文章著重探討 Java 21 引入的虛擬執行緒，並將其與傳統的快取執行緒池 (Cached Threads) 和固定執行緒池 (Fixed Threads) 進行比較，以突出虛擬執行緒對擴展性和響應能力的影響。

## ⏱️ 現代 PostgreSQL 應用的零延遲資料分析

**Source:** https://dzone.com/articles/zero-etl-postgresql-redshift-analytics

-   **AWS 零 ETL 整合**：2025 年 7 月 23 日，AWS 宣布推出 Amazon RDS for PostgreSQL 與 Amazon Redshift 的零 ETL (Zero-ETL) 整合。
-   **近即時分析**：此整合使客戶能夠對數 PB 的交易數據進行近即時的分析和機器學習 (ML)。
-   **簡化資料管道**：透過消除構建和管理複雜資料管道的需求，簡化了從 Amazon RDS 到 Amazon Redshift 的資料分析，有助於從多個應用程式中獲取全面的洞察。
-   **功能與彈性**：
    -   支援從單一 Amazon RDS PostgreSQL 資料庫創建多個零 ETL 整合。
    -   每個整合可應用資料過濾，以包含或排除特定資料庫和表格。
    -   可使用 AWS CloudFormation 自動化零 ETL 整合的配置和部署。
-   **Redshift 的分析能力**：數據在寫入 Amazon RDS for PostgreSQL 後數秒內即可複製到 Amazon Redshift，用戶可以利用 Redshift 強大的分析功能，包括整合的 ML、Spark 支援和實體化視圖，增強對近即時數據的分析。

## 🤖 AI 微管理的好處

**Source:** https://dzone.com/articles/the-benefits-of-ai-micromanagement

-   **AI 微管理價值**：當向 ChatGPT 等 AI 工具提供逐步增加的實際情境上下文時，AI 微管理展現出其優勢。
-   **情境策劃的重要性**：文章通過一項回顧性設計的實驗（五個提示，從零上下文到完整團隊背景與擴展推理時間）說明：
    -   零上下文的情況下，AI 產生了通用且無意義的內容。
    -   提供戰略性的情境策劃後，AI 提供了複雜的根本原因分析，針對慢性自上而下的壓力、依賴關係僵局和心理安全侵蝕等問題。
-   **結論**：更多的上下文會產生更好的解決方案，但前提是這些上下文是相關且結構化的，強調了「戰略性情境策劃」的關鍵作用。

## 🏗️ Pulumi：使用真實程式語言實現現代基礎設施即程式碼

**Source:** https://dzone.com/articles/pulumi-infrastructure-as-code

-   **Pulumi 簡介**：Pulumi 成立於 2017 年，是一個現代的基礎設施即程式碼 (IaC) 平台，旨在彌合軟體開發和基礎設施管理之間的鴻溝。
-   **基於通用程式語言**：它允許開發人員和基礎設施團隊使用熟悉的程式語言（而不是特定領域語言 DSL 或 YAML 模板）來創建、部署和管理雲端資源。
-   **傳統 IaC 工具的替代方案**：對於那些希望使用自己選擇的程式語言編寫 IaC 程式碼的開發者來說，Pulumi 是一個強大的替代方案，尤其是在 Terraform 引入 HCL2 之後。

## 🛑 如何在 Spring Boot 應用程式中實作緊急開關 (Kill Switch) 功能旗標

**Source:** https://dzone.com/articles/kill-switch-feature-flags-spring-boot

-   **緊急開關 (Kill Switch) 的定義**：緊急開關是一種功能旗標 (feature flag)，允許您快速關閉應用程式中的特定功能。
-   **實用場景**：
    -   緊急關閉外部 API 和服務。
    -   應對突如其來的垃圾郵件或流量高峰。
    -   在需要快速制止某個操作而不引起額外中斷的其他營運事件。
-   **實作教學**：本教學示範如何使用 LaunchDarkly Java SDK 在 Spring Boot 應用程式中加入緊急開關功能。
-   **範例**：教程以 Motivational Messages API 作為資料源，展示如何在一個免費且無需身份驗證的 API 上實作殺死開關。