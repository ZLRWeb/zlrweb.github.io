---
slug: tech-summary-2025-10-16
title: TechSummary 2025-10-16
authors: gemini
tags: [GitHub, TechConferences, IntrovertTips, Docker, Debugging, VSCode, JetBrains, PluginDevelopment, GoProgramming, BestPractices, CloudDevelopment, AI, ProductUpdates]
---

# TechSummary 2025-10-16

## 🤝 如何以內向者的身份參與 GitHub Universe (或任何技術大會)

**Source:** https://github.blog/news-insights/company-news/how-to-navigate-github-universe-or-any-tech-conference-if-youre-an-introvert/

-   技術大會對內向者可能感到不知所措，但 GitHub Universe 專為此設計，提供休息空間、小型團體交流及線上參與選項。
-   **參與小型研討會或工作坊：** 選擇人數較少、互動性強的環節，如深度工作坊、小組討論、實作沙盒課程，避免在大會中迷失。
-   **尋找安靜區與充電空間：** 大會設有專用休息室和安靜房間，供冥想、祈禱或單純放鬆，並提供飲食補充能量。戶外環境也能幫助放鬆。
-   **參與策劃的交流活動：** 尋找有主題或引導的社交活動，例如 Recess!（基於共同興趣）、Makerspace（創作互動專案）和 Open Source Zone（與貢獻者交流），避免無目的的大型社交場合。
-   **設定個人目標與界限：** 預先規劃議程，明確想參與的環節和想見的人，並安排充足的休息時間。GitHub Universe 提供議程規劃工具，幫助您按自己的步調進行。
-   **準備話題引導物：** 穿戴與興趣相關的 T 恤、胸針或貼紙，可以輕鬆開啟對話，降低社交壓力。大會現場也提供周邊商品以協助開啟話題。
-   **透過線上方式參與：** 如果不適合親身出席，可選擇虛擬參與、觀看直播或隨選回放主要演講和部分環節，確保仍能參與和學習。

<!-- truncate -->

## 🐛 使用 Visual Studio Code 偵錯 Docker 建置

**Source:** https://www.docker.com/blog/debug-docker-builds-with-visual-studio-code/

-   Docker 映像檔建置是現代應用程式軟體交付的關鍵，但 Dockerfile 在修改和偵錯時常面臨挑戰，難以理解建置時的狀態。
-   Docker 通過更新 Buildx 和 VS Code 擴展 (Docker DX)，引入了 **VS Code 中的建置偵錯功能**，以縮短 Docker 建置問題的修復時間。
-   **配置 Visual Studio Code：**
    -   安裝最新版 Docker DX 擴展。
    -   更新 Docker Desktop 到最新版，確保擁有最新的 Docker 建置工具。
    -   執行 `docker buildx version` 並確認 Buildx 版本至少為 0.29.x。
-   **建立啟動配置：** 在 Visual Studio Code 中開啟 Dockerfile 並建立或編輯 `launch.json` 檔案，新增偵錯配置：
    ```json
    {
      "name": "Docker: Build",
      "type": "dockerfile",
      "request": "launch",
      "dockerfile": "Dockerfile",
      "contextPath": "${workspaceFolder}"
    }
    ```
-   **新增斷點：** 在 Dockerfile 的 `RUN` 指令旁點擊編輯器左側邊界或按 F9 設定斷點。
-   **啟動偵錯器：** 選取您建立的啟動配置並按 F5，建置過程將在斷點處暫停。
-   **偵錯功能：**
    -   **檢查變數：** 在建置暫停時，檢視已定義的變數，例如 `WORKDIR`、`VAR` 和 `NODE_VERSION`，以診斷配置問題。
    -   **檔案總管：** 檢視正在建置的 Docker 映像檔的檔案系統結構，並可查看文本檔案的內容。
    -   **互動式偵錯：** 在偵錯主控台輸入 `exec` 並按下 Enter 鍵，即可開啟一個連接到正在建置映像檔的 shell 終端，方便檢查其內容和執行測試命令。
      ```
      exec
      ```
      此功能大幅簡化了傳統的偵錯流程，但請注意，在 `exec` 終端中進行的任何更改都不會被持久化到最終映像檔中。
-   **基於開放規範的整合：** Buildx 偵錯器基於 Debug Adapter Protocol (DAP) 實作，可與支援該協定的任何編輯器整合，例如 Neovim (透過 `nvim-dap-docker`) 和 JetBrains 編輯器 (透過 LSP4IJ 插件)。

## 📅 JetBrains 插件開發者大會 2025 即將舉行！

**Source:** https://blog.jetbrains.com/platform/2025/10/jetbrains-plugin-developer-conf-2025-is-coming-up-soon/

-   JetBrains 插件開發者大會將於 2025 年 11 月 5 日（星期三）舉行，為期一天，包含啟發性演講、即時問答和插件開發深度探討。
-   **目標受眾：** 無論是剛入門或已在 JetBrains Marketplace 上發布插件的開發者，都能從中獲得新想法、實用技術和成功經驗分享。
-   **議程亮點：**
    -   由 Ivan Chirkov、Jakub Chrzanowski 和 Robert Novotny 發表的主題演講。
    -   Dmitrii Derepko 的「從模板到 Marketplace：建立你的第一個插件」。
    -   Aleksandr Slepchenkov 的「開發語言插件：LSP 與學習的樂趣」。
    -   其他主題包括 Kotlin Notebook、YouTrack 應用程式、AI 輔助測試生成、IntelliJ 插件遠端開發友好性及 UI 凍結問題調查等。
-   **參與方式：** 演講將在 YouTube 上直播，所有場次在活動結束後仍可隨選觀看，方便錯過直播的觀眾補看。

## ✨ 高效能 Go 的「10 倍」準則

**Source:** https://blog.jetbrains.com/go/2025/10/16/the-10x-commandments-of-highly-effective-go/

-   John Arundel 分享了十條 Go 語言開發的卓越準則，旨在幫助開發者撰寫更佳程式碼，提升效率。
-   **1. 撰寫套件，而非程式：** 設計可重用的套件，讓 `main` 函式僅負責參數解析和錯誤處理，核心邏輯由「領域」套件完成。套件應返回資料和錯誤，而非直接印出或退出程式，保持模組結構簡單。
-   **2. 全面測試：** 透過撰寫測試來「試用」自己的套件，命名測試應清晰如句子，專注於使用者可見的小行為，並加入整合測試。利用 GoLand 的生成測試功能、覆蓋率分析和偵錯器。
-   **3. 撰寫易於閱讀的程式碼：** 優先考慮可讀性，使用一致的命名慣例（如 `err` 用於錯誤，`data` 用於任意 `[]byte`，`ctx` 用於上下文），並透過將低階操作提取成小函式來簡化冗長的功能。
-   **4. 預設安全性：** 設計型別時確保零值有用，或使用驗證建構函式來保證物件始終有效（如 `widget := NewWidget().WithTimeout(time.Second)`）。使用具名常數而非魔法值（如 `http.StatusOK`），利用 `iota` 自動賦值。使用 `os.OpenRoot` 防止路徑遍歷攻擊。
    ```go
    root, err := os.OpenRoot("/var/www/assets")
    if err != nil {
        return err
    }
    defer root.Close()
    file, err := root.Open("../../../etc/passwd") // Error: 'openat ../../../etc/passwd: path escapes from parent'
    ```
-   **5. 包裝錯誤，而非扁平化：** 定義具名「哨兵」錯誤值（如 `var ErrOutOfCheese`），使用 `errors.Is` 進行錯誤匹配，而非字串比較或直接 `==`。通過 `fmt.Errorf` 搭配 `%w` 動詞來包裝錯誤，以保留上下文資訊。
    ```go
    // Example sentinel error
    var ErrOutOfCheese = errors.New("++?????++ Out of Cheese Error. Redo From Start.")

    // Wrapping an error
    return fmt.Errorf("GNU Terry Pratchett: %w", ErrOutOfCheese)

    // Checking against a wrapped error
    if errors.Is(err, ErrOutOfCheese) {
        // ...
    }
    ```
-   **6. 避免可變的全域狀態：** 使用 `sync.Mutex` 或專屬的「守護」goroutine 來管理併發存取，避免資料競爭。創建物件的新實例（如 `http.NewServeMux`），而非使用可能被第三方套件修改的全域物件。
-   **7. 謹慎使用（結構化）併發：** 僅在必要時引入併發。確保所有 goroutine 在封裝函式退出前終止，可使用 `context` 或 `sync.WaitGroup`。使用 `errgroups` 處理多個平行任務中的第一個錯誤。函數參數應只接收通道的發送或接收端，以避免死鎖。
    ```go
    var wg sync.WaitGroup
    wg.Add(2) // Initialize WaitGroup with count of tasks
    go func() {
        defer wg.Done()
        // task1 logic
    }()
    go func() {
        defer wg.Done()
        // task2 logic
    }()
    wg.Wait() // Blocks until all tasks complete

    // Using errgroup to manage parallel tasks and errors
    var eg errgroup.Group
    eg.Go(func() error {
        // task1 logic, return error if any
        return nil
    })
    eg.Go(func() error {
        // task2 logic, return error if any
        return nil
    })
    if err := eg.Wait(); err != nil {
        fmt.Printf("error %v: all other tasks cancelled\n", err)
    } else {
        fmt.Println("all tasks completed successfully")
    }
    ```
-   **8. 將程式碼與環境解耦：** 避免在套件深層依賴作業系統或環境變數。`main` 函式應負責處理環境配置。使用 `go:embed` 將靜態資料（如 `hello.txt`）嵌入二進制檔中，實現單一執行檔。
    ```go
    import _ "embed"

    //go:embed hello.txt
    var s string

    // fmt.Println(s) // `s` now has the contents of 'hello.txt'
    ```
    使用 `xdg` 代替硬編碼路徑，並在記憶體使用上保持節約，分塊處理資料以減少記憶體佔用和垃圾回收。
-   **9. 為錯誤設計：** 始終檢查並處理錯誤，在適當時機進行重試。將 `panic` 保留給內部程式錯誤，並向使用者報告執行時錯誤並優雅地退出。不要使用 `_` 忽略錯誤。
-   **10. 僅記錄可執行的資訊：** 避免記錄瑣碎訊息，僅記錄需要人為修復的錯誤。直接印出到控制台，讓使用者重定向輸出。切勿記錄機密或個人資料。使用 `slog` 生成機器可讀的 JSON 格式日誌。
    ```go
    logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))
    logger.Error("oh no", "user", os.Getenv("USER"))
    // Output example:
    // {"time":"...","level":"ERROR","msg":"oh no","user":"bitfield"}
    ```
    使用追蹤（tracing）代替日誌來進行請求範圍的故障排除，使用指標（metrics）代替日誌來記錄效能數據。

## 🌅 JetBrains 宣佈終止 CodeCanvas 服務

**Source:** https://blog.jetbrains.com/codecanvas/2025/10/jetbrains-is-sunsetting-codecanvas/

-   JetBrains 宣佈將終止其雲端開發環境 (CDE) 產品 CodeCanvas 的開發和服務。
-   **終止原因：** 由於近年 AI 的快速發展，軟體開發格局發生了巨大變化。JetBrains 認為 CodeCanvas 當前的 CDE 設定過於小眾，無法滿足 AI 時代不斷變化的使用者需求。
-   **產品時程：**
    -   從 2025 年 10 月 16 日起，不再提供新的 CodeCanvas 許可證或訂閱升級。
    -   對現有使用者的支援將持續到 2026 年 1 月 1 日。
    -   現有使用者可繼續使用 CodeCanvas 直到 2026 年 3 月 31 日。
    -   2026 年 3 月 31 日之後，CodeCanvas 公共資源將不再可用，服務實例將停止運作。
-   **未來展望：** JetBrains 團隊正在開發一款全新的、**AI 優先的雲端原生產品**，旨在幫助專業團隊採用 AI 並與自主 AI 代理合作，CDEs 在新產品設計中仍將扮演重要角色。JetBrains 感謝 CodeCanvas 使用者提供的寶貴意見，這些意見將用於改進新產品。