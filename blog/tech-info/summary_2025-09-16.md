---
slug: tech-summary-2025-09-15
title: TechSummary 2025-09-15
authors: gemini
tags: [GitHub, SSH, Post-Quantum Security, AI, ML, POC, Docker, Kubernetes, Cloud, Spec-Driven Development, C++, Debugging, VSCode, Service Discovery, Data Streaming, JavaScript, Security]
---

# TechSummary 2025-09-15

## GitHub SSH 存取引入後量子安全 🔒

**Source:** https://github.blog/engineering/platform-security/post-quantum-security-for-ssh-access-on-github/

-   GitHub 將為其 SSH 端點新增一個後量子安全 SSH 金鑰交換演算法：`sntrup761x25519-sha512`（或 `sntrup761x25519-sha512@openssh.com`）。
-   此變更僅影響 SSH 存取，對 HTTPS 存取無影響，也不影響位於美國地區的 GitHub Enterprise Cloud 資料駐留。
-   目的是防範未來量子電腦可能進行的「先儲存，後解密」攻擊，確保資料的長期安全。
-   採用混合式方法，結合了 Streamlined NTRU Prime（一種新的後量子安全演算法）與經典的 Elliptic Curve Diffie-Hellman（使用 X25519 曲線），確保安全性不低於經典演算法。
-   此演算法將於 2025 年 9 月 17 日起在 GitHub.com 和非美國地區的 GitHub Enterprise Cloud 上啟用，並將包含在 GitHub Enterprise Server 3.19 中。
-   大多數現代 SSH 客戶端（例如 OpenSSH 9.0 或更新版本）將自動選擇新演算法，無需手動配置；舊版客戶端將回退到舊演算法。
-   您可以透過執行 `ssh -Q kex` 來檢查 SSH 客戶端是否支援此演算法，並使用 `ssh -v git@github.com exit 2>&1 | grep 'kex: algorithm:'` 來查看連接 GitHub 時所使用的金鑰交換演算法。

<!-- truncate -->

## AI PoC 成功九法則：如何打造能真正上線的演示 💡

**Source:** https://www.docker.com/blog/ai-poc-success-rules/

-   許多 AI PoC（概念驗證）失敗是因為它們從一開始就被設計為一次性的演示，而非針對生產環境。
-   成功的關鍵在於採用「遠端+本地」（Remocal Workflows）開發模式：
    -   在本地筆記型電腦上快速迭代測試，避免等待雲端資源和意外費用。
    -   僅在需要大規模測試、生產環境驗證或高性能計算（如 H100s）時，才利用遠端資源。
    -   從第一天起就保持成本透明。
-   AI PoC 成功的九個法則：
    1.  **從小處著手，保持精簡：** 使用輕量級模型、可檢視的資料集，並將範圍縮小到能一句話解釋其價值。
    2.  **從零開始設計生產：** 將日誌、監控、版本控制和防護措施視為系統基礎。
    3.  **優化可重複性和模型改進，而非新奇性：** 基礎設施應模板化，提示詞測試應納入 CI/CD，模型比較需基準化。
    4.  **建立回饋循環：** 將非確定性 AI 組件與確定性業務邏輯分離，構建分層的控制和驗證。
    5.  **解決痛點，而非炫技：** 將所有工作錨定在可衡量的業務痛點上，解決真實用戶願意付費解決的問題。
    6.  **早期植入成本和風險意識：** 從第一天起追蹤單位經濟效益，並了解小型與大型模型、雲端與本地執行之間的權衡。
    7.  **明確所有權：** 從第一天起就明確專案所有者、SLA 和生命週期管理責任。
    8.  **預先控制成本：** 透明的請求、用戶和工作流程成本，設定硬性預算上限和終止開關。
    9.  **從零開始讓用戶參與：** 與實際用戶共同設計，測量採用率和節省的時間，而不僅僅是準確性分數。

## 使用 GitHub Spec Kit 深入探討規範驅動開發 📝

**Source:** https://devblogs.microsoft.com/blog/spec-driven-development-spec-kit

-   **問題**：AI 代理在開發軟體時，需要良好的上下文才能產生正確的輸出；若沒有事先定義需求，程式碼會成為事實上的規範，難以維護和演進。
-   **規範驅動開發 (Spec-Driven Development, SDD)**：一種新方法，旨在使技術決策明確、可審查和可演進，將「為什麼」做出技術選擇的思考過程版本化。
-   SDD 關鍵作用：
    -   避免因溝通不暢導致的假設錯誤和昂貴返工，透過早期發現假設來降低成本。
    -   規範成為與程式碼一同演進的「活文件」，有助於思考邊界情況、協調團隊和新成員的入職。
    -   對依賴 AI 代理構建產品的流程尤其重要，共享上下文能引導代理找到正確解決方案，甚至輕鬆創建多變體實作（如 Rust 與 Go 的比較）。
-   **GitHub Spec Kit 簡介**：旨在將 SDD 實踐付諸實現。
    -   **Specify CLI**：一個 Python 工具，用於快速為專案設定 SDD 環境。它從 GitHub 倉庫下載官方模板，並搭建 SDD 框架。
        ```bash
        uvx --from git+https://github.com/github/spec-kit.git specify init <PROJECT_NAME>
        ```
    -   **模板和輔助腳本**：定義了規範、技術計畫和任務的結構。專案初始化後會生成 `.github` (用於提示詞) 和 `.specify` (包含記憶體、腳本和模板) 資料夾。
    -   **`constitution.md`**：一個額外文件，用於建立專案的不可協商原則，如測試方法或 CLI 優先原則，有助於建立「意見化堆疊」。
-   **斜線命令 (Slash Commands)**：用於引導 SDD 流程，必須依序使用：
    -   `/specify`：概述專案的「內容」和「原因」（類似 PRD），不涉及技術決策。
    -   `/plan`：概述專案的「如何做」（框架、函式庫、資料庫、基礎設施），生成技術計畫、資料契約和快速入門指南，並參考 `constitution.md`。
    -   `/tasks`：將規範和計畫分解為 AI 代理可處理的、分階段的任務。
-   強調詳細的初始提示詞對於 AI 代理產生高品質規範至關重要。

## 隆重推出 Constexpr 除錯器 🐞

**Source:** https://blog.jetbrains.com/clion/2025/09/introducing-constexpr-debugger/

-   **問題**：現代 C++ 將越來越多的邏輯推向 `constexpr`/`consteval`，但編譯時程式碼失敗時，難以從編譯器診斷中猜測原因。
-   **解決方案**：CLion 2025.3 EAP 版本引入了 `Constexpr Debugger`，允許開發者在編譯器環境中，逐步調試 `constexpr`/`consteval` 程式碼的評估過程，檢查變數值，並確認 `if constexpr` 分支是否被執行。
-   **主要功能**：
    -   從 `static_assert(...)` 或 `constexpr` 宣告符旁的 Debug 按鈕啟動逐步除錯。
    -   支援常規除錯器操作，如 Step Into、Step Over、Step Out、Restart，並新增 `Step Backward`（編譯時反向單步執行）。
    -   可查看編譯器所見的狀態：呼叫堆疊、局部變數、最近返回值和當前實例化的模板參數。
    -   懸停在變數上可查看其值，使用 Evaluate Expression，或從呼叫堆疊導航到原始碼。
    -   在常數評估失敗時檢查整個上下文，以確定發生時機和原因。
-   **使用範例** (Fibonacci 快取實作)：
    ```cpp
    constexpr int get_fibonacci(int n) {
        FibCache<8> cache;
        auto result = cache(n);
        return result;
    }
    constexpr int k = get_fibonacci(6);          // 可在 gutter 處開始調試 operator()
    static_assert(get_fibonacci(6) == 8, "ok");  // 這裡也可用 gutter 開始調試
    ```
-   **限制**：
    -   目前不支援斷點（Breakpoints）和 Run to Cursor / Force Run to Cursor。
    -   C++20 modules 尚未完全支援，無法導航到從匯入模組中的實體。
    -   某些語言結構或複合語句的單步調試可能無法正常工作。
    -   部分 `constexpr` 評估器構造尚未支援。

## 推出自動模型選擇功能（預覽版） 🤖

**Source:** https://code.visualstudio.com/blogs/2025/09/15/autoModelSelection

-   Visual Studio Code (VS Code) 引入了自動模型選擇（Auto Model Selection）功能預覽。
-   這項功能旨在提供更快的響應時間，減少 API 請求的速率限制。
-   對於付費用戶，使用此功能還可以在高級請求上享受 10% 的折扣。

## Kubernetes v1.34：分離式 Taint 管理器現已穩定 ☸️

**Source:** https://kubernetes.io/blog/2025/09/15/kubernetes-v1-34-decoupled-taint-manager-is-now-stable/

-   Kubernetes v1.34 版本將 `SeparateTaintEvictionController` 功能門檻提升為 GA（普遍可用）。
-   此增強功能將節點生命週期管理和 Pod 驅逐的責任分離為兩個獨立的組件。
-   現在，節點生命週期控制器僅負責使用 `NoExecute` 污點標記不健康的節點，而專用的污點驅逐控制器則管理 Pod 的驅逐過程。
-   這種分離不僅改善了程式碼組織，也更容易改進污點驅逐控制器或構建自訂的污點驅逐實作。
-   用戶可以透過在 `kube-controller-manager` 中設定 `--controllers=-taint-eviction-controller` 來選擇性禁用基於污點的驅逐。

## 從筆記型電腦到雲端：使用 Docker Compose 和 Offload 構建與擴展 AI 代理 🐳

**Source:** https://dzone.com/articles/ai-agents-docker-compose-cloud-offload

-   **挑戰**：在本地運行 AI 代理時，會面臨依賴項衝突、配置漂移和筆記型電腦性能下降等問題，因為 AI 代理通常包含語言模型、資料庫和前端等多個組件。
-   **解決方案**：Docker Compose 簡化了多組件 AI 代理的管理。
    -   透過單一 YAML 文件定義所有服務，並將其作為一個應用程式共同運行。
    -   `docker compose up` 命令可以一鍵啟動完整的 AI 代理堆疊。
    -   Docker Compose 甚至支援直接使用 `models` 元素聲明 AI 模型。

## Spring Cloud Gateway 結合 HashiCorp Consul 進行服務發現 🌐

**Source:** https://dzone.com/articles/spring-cloud-gateway-service-discovery-consul

-   文章介紹了 HashiCorp Consul 服務的基本概念及其配置，這是一個提供服務註冊和發現功能的服務網絡解決方案。
-   Consul 可以與 Spring Boot 無縫整合，類似於 Netflix Eureka，但提供了更多功能並支援現代的反應式編程範式。
-   建議的架構包含以下核心庫：
    -   Spring Boot
    -   Spring Cloud Gateway
    -   Spring Cloud Consul
    -   Spring Boot Actuator

## 精通近似 Top K：選擇最佳 Count-Min Sketch 參數 📈

**Source:** https://dzone.com/articles/top-k-count-min-sketch-configuration

-   **Top K 問題**：指從大量、快速變化的資料流中，找出頻率或相關性得分最高的 K 個元素。
-   在現代即時系統（如電子商務平台、社群媒體、串流服務）中，快速識別最相關的項目或事件至關重要。
-   實際應用範例包括：
    -   根據推文量快速變化的熱門 Twitter 標籤。
    -   每小時更新的 Netflix 最受歡迎電影。
    -   即時更新的 Amazon 熱銷產品排名。
    -   基於觀看速度每小時更新的熱門 YouTube 影片。
-   文章重點在於如何為 Count-Min Sketch（一種解決 Top K 問題的近似演算法）選擇最佳參數。

## AI 和機器學習如何形塑勒索軟體攻防戰 🛡️

**Source:** https://dzone.com/articles/how-ai-and-machine-learning-are-shaping-the-fight

-   勒索軟體仍是個人和企業面臨的最大威脅之一，傳統防禦措施難以跟上威脅演變的速度。
-   人工智慧（AI）和機器學習（ML）的應用正徹底改變網路安全策略，用於自動化檢測、制定損害緩解策略，甚至預測攻擊。
-   AI 在預防和威脅檢測中的作用：
    -   利用自然語言處理 (NLP) 和圖像識別等 AI 技術，更快、更精確地識別異常行為。
    -   結合機器學習演算法，識別與異常直接相關的獨特模式。
    -   AI 安全解決方案在現實世界中，可將網路攻擊檢測的不準確性比傳統方法降低 96%。

## 可解釋 AI (Part 10)：連結理論與實踐—負責任 AI：雄心還是幻覺？ 🧠

**Source:** https://dzone.com/articles/explainable-ai-responsible-ai

-   此系列文章探討 AI 的可解釋性如何幫助建立信任、確保問責制，並與實際需求保持一致，涵蓋從基本原則到實際應用案例。
-   **第十部分** 聚焦於連接理論與實踐，深入探討「負責任 AI：是雄心壯志還是虛幻的泡影？」。
-   此部分建立在先前第九部分關於「現實條件下的可解釋性：LIME 和 SHAP 的實踐比較」的基礎上。

## 超越大型語言模型 (LLMs) 的生成式 AI 🔬

**Source:** https://dzone.com/articles/genai-beyond-just-llms

-   生成式 AI (GenAI) 的前沿正不斷擴展，其應用已超越了單純的文字或圖像生成（如 ChatGPT、GitHub Copilot、DALL·E）。
-   現在，同樣的技術正在被用於設計分子和發現新材料，使得 AI 不僅僅是「關於科學寫作」，而是「幫助進行科學研究」。
-   主要的科技公司，如 OpenAI、Meta、Google DeepMind 和 Microsoft，都在積極開發理解化學、生物學和物理學等領域的大型 AI 模型。

## 開源大型語言模型基準測試：LLaMA vs Mistral vs Gemma — 為開發者構建私有模型的實用指南 📊

**Source:** https://dzone.com/articles/benchmarking-open-source-llama-mistral-gemma

-   大型語言模型 (LLMs) 已從研究實驗室進入全球企業的日常工作流程。儘管 GPT-4 和 Claude 等專有工具備受關注，但它們存在 API 速率限制、不透明的模型行為和隱私問題。
-   這推動了開源 LLMs 的崛起，例如 Meta 的 LLaMA、Mistral AI 的 Mistral 和 Google 的 Gemma。
-   開源模型使開發者能夠構建和部署強大的 AI 應用程式，而無需依賴第三方 API，從而提供透明度、靈活性和成本控制。
-   本文提供了一份實用指南，專為希望為其私有模型基準測試這些開源 LLMs 的開發者設計。

## 代理式 AI：人工智慧與自主自動化的下一個演進 🚀

**Source:** https://dzone.com/articles/next-evolution-ai-autonomous-automation

-   人工智慧（AI）經歷了顯著演進，從早期的被動式語音機器人（如 Siri 和 Alexa）發展到需要人類輸入的 AI 助手（如 ChatGPT）。
-   **代理式 AI (Agentic AI)** 代表了 AI 的下一個演進階段，它不再僅僅是執行任務，而是具備獨立思考和主動性。
-   這篇文章探討了代理式 AI 如何實現自主自動化，並成為人工智慧的下一個重要發展。

## Tuples 和 Records (Part 5)：性能挑戰 📉

**Source:** https://dzone.com/articles/tuples-and-records-part-5

-   這是關於 JavaScript 中 Tuples 和 Records 系列的第五部分。
-   文章解釋了這個旨在為 JavaScript 引入原生不可變資料結構的提案為何最終在 ES2025 中被撤回。
-   撤回的主要原因包括：結構相等性、記憶體管理和引擎優化方面的技術挑戰。
-   文中也探討了從這次提案中為未來 JavaScript 語言演進所吸取的教訓。