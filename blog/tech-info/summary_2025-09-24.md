---
slug: tech-summary-2025-09-23
title: TechSummary 2025-09-23
authors: gemini
tags: [AI, Technology, Summary, Java, GitHubCopilot, Modernization, VSCode, Azure, CVE, SoftwareDevelopment, npm, SupplyChainSecurity, OpenSource, TwoFactorAuthentication, TrustedPublishing, Malware, Security, Docker, MCP, AIInfrastructure, Vulnerability, Localhost, DriveByAttack, NetworkSecurity, Ktor, Kotlin, WebDevelopment, OpenAPI, WebRTC, gRPC, ServiceDiscovery, DependencyInjection, Roadmap, WebStorm, Refactoring, React, CodeQuality, FrontendDevelopment, JavaScript, TypeScript, TestGeneration, UnitTesting, IntelliJIDEA, TestSpark, LLM, SoftwareTesting, CodeCoverage, EdgeComputing, DecentralizedAI, Privacy, EnergyEfficiency, MLOps, Kubernetes, MLflow, KServe, vLLM, ModelServing, GPUManagement, Agile, ProjectManagement, Traceability, Requirements, CloudInfrastructure, DevOps, AIReadiness, MachineLearning, ModelEvaluation, Metrics, Accuracy, Precision, Recall, F1Score, ROCAUC, FluentBit, Telemetry, CNCF, Observability, Logging, CloudNative, TestAutomation, Antipatterns, QualityAssurance, LeastPrivilege, APIKeys, AccessControl, DevOpsSecurity, Experimentation, ProductManagement, DataScience, RADPlatforms, RapidApplicationDevelopment, LowCode, NoCode, Productivity, ShaiHulud, CloudCredentials, GitHubActions, Nx, BuildSystem, DataExfiltration]
---

# TechSummary 2025-09-23

## 🚀 使用 GitHub Copilot 代理模式現代化 Java 專案的逐步指南

**Source:** https://github.blog/ai-and-ml/github-copilot/a-step-by-step-guide-to-modernizing-java-projects-with-github-copilot-agent-mode/

- GitHub Copilot 代理模式將 Copilot 從被動建議工具轉變為主動協作夥伴，能理解高層次指令並執行多步驟任務，無需詳細指示。
- 搭配 GitHub Copilot 應用現代化 VS Code 擴充功能，此工具組提供互動式、逐步指引，幫助開發者更快、更少錯誤地升級和遷移 Java 專案。
- 現代化流程包括：分析專案、生成升級計畫、自動應用變更、修復建構問題、驗證測試、檢測並修復 CVEs，並提供完整的摘要報告。
- 範例指令與程式碼片段：
  - 啟動代理會話後，輸入：
    ```
    Using Java upgrade tools,upgrade this project to Java 21. Analyze deprecated APIs, update Gradle dependencies, and propose a safe, testable migration plan.
    ```
  - 程式碼升級前後對比：
    ```java
    // Before (deprecated constructor)
    View view = this.resolver.resolveViewName("intro", new Locale("EN"));

    // After Java 21 upgrade
    View view = this.resolver.resolveViewName("intro", Locale.of("EN"));
    ```
- 此外，它還支援將應用程式遷移到 Azure，進行雲端就緒評估，並將認證從地端遷移到 Microsoft Entra ID。
- 自動化 CVE 掃描是其關鍵安全功能，可智慧地提出安全版本替換或推薦替代函式庫，以維持安全合規。

<!-- truncate -->

## 🔒 我們加固 npm 供應鏈的計畫

**Source:** https://github.blog/security/supply-chain-security/our-plan-for-a-more-secure-npm-supply-chain/

- 開源軟體是現代軟體產業的基石，但其大規模生態系統也帶來了獨特的漏洞，不斷遭受惡意攻擊者的威脅。
- 近期 npm 註冊中心發生帳戶遭劫持事件，例如 2025 年 9 月 14 日的「Shai-Hulud」蠕蟲攻擊，透過惡意後安裝腳本感染了 500 多個套件。
- GitHub 迅速應對，包括立即從 npm 註冊中心刪除受損套件並阻止上傳包含惡意軟體 IoC 的新套件。
- npm 未來將透過以下措施加強套件發佈安全性：要求本地發佈使用雙因素驗證 (2FA)、提供有限生命週期（七天）的精細權杖，以及推廣信任發佈 (Trusted Publishing)。
- 為支援這些變革，npm 將棄用舊版傳統權杖、將 TOTP 2FA 遷移到基於 FIDO 的 2FA，並預設禁止權杖發佈存取。
- 強烈鼓勵專案盡快採用已在 PyPI、RubyGems、crates.io 和 NuGet 等多個套件管理器中實現的信任發佈功能。

## 💀 MCP 恐怖故事：本機主機 Drive-By 攻擊漏洞

**Source:** https://www.docker.com/blog/mpc-horror-stories-cve-2025-49596-local-host-breach/

- **CVE-2025-49596** 是一個 MCP Inspector 中的關鍵漏洞（CVSS 評分 9.4），將常用的 AI 代理偵錯工具轉變為大規模破壞的武器。
- 攻擊者只需誘騙開發者訪問惡意網站，即可透過瀏覽器觸發 Drive-by 攻擊，在開發者機器上實現遠端程式碼執行，無需下載或釣魚。
- **問題根源：** 傳統 MCP Inspector 設定（例如 `npx @modelcontextprotocol/inspector`）將偵錯介面暴露在 `http://0.0.0.0:6277`，且不帶任何安全控制，允許任何來源的 HTTP 請求。
- **攻擊機制：** 惡意 JavaScript 利用瀏覽器對 `0.0.0.0` 的錯誤處理（將其等同於 `localhost`）來繞過同源策略，並使用 `mode: "no-cors"` 向 `http://0.0.0.0:6277/sse` 發送請求。一旦控制 MCP Inspector，攻擊者可以注入惡意工具呼叫，竊取憑證、存取私有儲存庫並實現系統妥協。
- **Docker MCP Gateway 解決方案：** 透過網路隔離架構完全消除此攻擊向量，不暴露本機主機網頁服務，並使用安全的 stdio 傳輸。
- **安全配置範例：**
    ```bash
    docker mcp gateway run --transport stdio
    ```
    進一步的容器化部署範例：
    ```bash
    docker run -d \
      --name mcp-gateway \
      --network mcp-isolated \
      -p 8811:8811 \
      -v /var/run/docker.sock:/var/run/docker.sock:ro \
      -v ~/.docker/mcp:/mcp:ro \
      --use-api-socket \
      docker/mcp-gateway \
      --catalog=/mcp/catalogs/docker-mcp.yaml \
      --config=/mcp/config.yaml \
      --registry=/mcp/registry.yaml \
      --tools-config=/mcp/tools.yaml \
      --transport=sse \
      --port=8811
    ```
- **最佳實踐：** 立即將 MCP Inspector 升級到 0.14.1+ 版本，部署 Docker MCP Gateway 等安全替代方案，實施網路隔離，要求身份驗證。

## 🗺️ Ktor 路線圖與預覽

**Source:** https://blog.jetbrains.com/kotlin/2025/09/ktor-roadmap-2025/

- Ktor 3.3.0 版本已發布 OpenAPI 和 WebRTC 支援的早期預覽。
- **Ktor Library Improvement Process (KLIP)**：Ktor 團隊透過公開的功能提案來徵求社群回饋，以引導開發方向。
- **OpenAPI 文件**：Ktor 可在編譯時自動從程式碼中生成 OpenAPI 模型，透過新的 Ktor Gradle Plugin 進行配置。
    ```gradle
    plugins {
        kotlin(libs.plugins.kotlin)
        alias(libs.plugins.ktor)
    }

    ktor {
        @OptIn(OpenApiPreview::class)
        openapi {
            target = project.layout.projectDirectory.file("api.json")
            title = "My Service"
            summary = "What it does"
            description = "A longer description of the service"
            version = "1.0.0"
            // contact, termsOfService, license...
        }
    }

    dependencies {
        implementation(libs.ktor.server.core)
        implementation(libs.ktor.server.openapi)
    }
    ```
- **服務發現 (Service Discovery)**：新的 Ktor 插件為 Consul、Kubernetes、Zookeeper、Eureka 等流行的發現機制提供統一的抽象層，支援客戶端和伺服器端發現模式。
    ```kotlin
    install(ServiceDiscovery) {
       consul {
          connection { host = "localhost"; port = 8500 }
          registration { serviceName = "sample-service"; instanceId = "sample-service:$host:$port"; port = 8080 }
       }
    }
    val client = HttpClient {
        install(ServiceDiscovery) { consul { connection { host = "localhost"; port = 8500 } } }
    }
    client.get("service://sample-service")
    ```
- **WebRTC 支援**：旨在提供統一的多平台 API，支援瀏覽器、Android，未來計畫擴展到 JVM、iOS 和 Native 平台，也考慮支援基於 Rust 的 WebRTC 客戶端。
    ```kotlin
    val jsClient = WebRtcClient(JsWebRtc) {
     defaultConnectionConfig = { iceServers = listOf(WebRtc.IceServer("stun:stun.l.google.com:19302")) }
    }
    val jsConnection = jsClient.createPeerConnection()
    jsConnection.dataChannelEvents.collect { event ->
       when (event) {
         is Open -> println("Another peer opened a chanel: ${event.channel}")
         is Closed -> println("Data channel is closed")
         is Closing, is BufferedAmountLow, is Error -> println(event)
       }
    }
    ```
- **gRPC**：透過 `kotlinx-rpc` 函式庫為 Ktor 帶來 gRPC 支援，可以從 Kotlin 介面或 `.proto` 文件定義服務。
    ```kotlin
    @Grpc
    interface GrpcService {
        suspend fun sayHello(request: HelloRequest): HelloResponse
    }
    fun Application.installGrpc() = grpc {
        registerService<MyService> { MyServiceImpl() }
    }
    ```
- **Koog 整合**：新的 Ktor Koog 插件使開發者能夠輕鬆使用 Ktor 和 Koog 創建代理服務。
- **依賴注入 (Dependency Injection)**：計畫透過編譯器插件進一步增強依賴注入支援，提供編譯時驗證並更好地支援其他平台。

## ✨ 從 AI 生成到生產就緒程式碼：WebStorm 重構工具實現現代化工作流程

**Source:** https://blog.jetbrains.com/webstorm/2025/09/from-ai-generated-to-production-ready-code-webstorm-refactorings-for-the-modern-workflow/

- 雖然 AI 擅長快速生成功能性程式碼，但將其轉化為可維護、生產就緒的程式碼，是 WebStorm 重構工具的關鍵作用。
- **步驟 1：為內聯類型提取類型別名**：將內聯類型定義自動轉換為介面，提高可讀性和可重用性。
    ```typescript
    interface AnalyticsData {
      totalUsers: number;
      previousTotalUsers: number;
      revenue: number;
      previousRevenue: number;
      pageViews: number;
      previousPageViews: number;
      conversionRate: number;
      previousConversionRate: number;
      recentActivity: RecentActivity[];
    }
    const [analyticsData, setAnalyticsData] = useState<AnalyticsData | null>(null);
    ```
- **步驟 2：重新命名以提高清晰度**：使用 Shift+F6 智能重新命名變數（例如 `data` 改為 `analyticsData`），WebStorm 會自動更新所有引用。
- **步驟 3：提取可重用組件**：將重複的 JSX 模式提取為獨立組件，WebStorm 會自動識別並生成其 props。
- **步驟 4：新增 Props 以提高可重用性**：利用 Alt+Enter 快速修復，自動將新的 prop 添加到組件介面中，確保一致性。
- **步驟 5：使用錯誤邊界和載入狀態包圍**：使用 Ctrl+Alt+T/⌥+⌘+T 將內容包圍在錯誤處理（例如 `<ErrorBoundary>`）或條件邏輯中。
- **步驟 6：智能字串重構**：WebStorm 會自動將字串拼接轉換為模板字串，提高可讀性。
    ```typescript
    // Before
    return months[date.getMonth()] + ' ' + date.getDate() + ', ' + date.getFullYear();
    // After (automatic conversion)
    return `${months[date.getMonth()]}/${date.getDate()}/${date.getFullYear()}`;
    ```
- **結論**：AI 負責快速原型開發，WebStorm 負責確定性、安全且全面的重構，兩者結合可實現速度與品質的最佳平衡。

## 🧪 使用 in-IDE TestSpark 超級強化單元測試生成

**Source:** https://blog.jetbrains.com/research/2025/09/testspark-unit-test-generation/

- TestSpark 是一個由 JetBrains 和 TU Delft 合作開發的 IntelliJ IDEA 插件，用於 Java 和 Kotlin 程式的單元測試生成，結合了基於 LLM 和自動化測試技術。
- 傳統自動化測試技術（如隨機測試、基於搜索的測試和動態符號執行）雖有優點，但缺乏領域知識且使用者介面不友善。
- LLM-based 測試生成（如 TestPilot, ChatUniTest, TestSpark）利用模型對原始碼的理解來生成測試案例，但面臨無法編譯、數據洩露和非確定性等挑戰。
- TestSpark 透過其友善的 IDE 整合和智能反饋迴圈克服了 LLM 的限制：若測試無法編譯，它會將編譯錯誤作為提示發送給 LLM 進行修復。
- **工作流程：** 使用者右鍵點擊單元 -> 選擇 TestSpark 選項 -> 選擇測試生成技術和 LLM -> 生成測試 -> 在 IDE 內視覺化覆蓋率和結果 -> 直接修改、重新運行並選擇要添加到程式碼庫的測試。
- **技術亮點：** 完全嵌入 IDE、開源且可擴展、利用 IntelliJ IDEA 的實時上下文為 LLM 生成提示，確保生成可靠且可編譯的測試案例。
- 實驗結果顯示，LLM-based 的 TestSpark 在變異分數上顯著優於傳統工具，表明其在語義理解上的優勢；而在覆蓋率方面，傳統工具表現相似且優於 TestSpark。

## 🌐 邊緣 LLM：去中心化力量與控制

**Source:** https://dzone.com/articles/lms-edge-decentralized-power-control

- 大多數大型語言模型（LLM）應用部署在集中式雲端環境，引發延遲、隱私和能源消耗問題。
- 本文探討了 LLM 在去中心化邊緣運算中的潛在應用，計算任務分佈在互連設備上而非集中式主機。
- 透過量化、模型壓縮、分佈式推理和聯邦學習等方法，LLM 得以克服邊緣設備有限的計算和記憶體資源限制。
- 去中心化帶來多重優勢，包括增強隱私、使用者控制和系統穩健性，同時專注於採用節能方法和動態電源模式。
- 結論強調邊緣 AI 是未來去中心化 AI 技術的發展方向，提供以隱私為中心、高效能且使用者至上的解決方案。

## 📦 在 Kubernetes 上運行 AI/ML：從原型到生產 — 使用 MLflow, KServe 和 vLLM 在 Kubernetes 上自信地交付模型

**Source:** https://dzone.com/articles/ai-ml-kubernetes-mlflow-kserve-vllm

- 機器學習模型訓練後，推理階段必須快速、可靠且具成本效益。大規模推理面臨 GPU/資源管理、延遲和批處理、模型/版本發佈、可觀察性和輔助服務編排等挑戰。
- 在 Kubernetes 上運行人工智慧和機器學習（AI/ML）提供了一個可擴展、可移植的平台，用於訓練和服務模型。
- Kubernetes 可高效調度 GPU 和其他資源，實現工作負載的有效打包，並根據流量自動擴展，適用於批處理作業和實時推理。
- 它還協調多組件堆棧（如模型伺服器、預處理器、向量數據庫和特徵儲存），確保複雜的管道和低延遲端點可靠運行。
- 推薦使用 MLflow、KServe 和 vLLM 搭配 Kubernetes，以自信地將模型投入生產。

## ⚓ 從需求到結果：以可追溯性錨定敏捷開發

**Source:** https://dzone.com/articles/anchoring-agile-with-traceability

- 敏捷開發因其增量交付、快速適應變化和協作優先的特點，成為軟體開發領域最廣泛採用的專案管理方法之一。
- 然而，敏捷的快速變化本質也可能暴露出其弱點：可追溯性。傳統專案管理方法（如瀑布模型）將需求與設計文件、測試案例和驗收指標緊密聯繫，確保每個功能都能追溯到其源頭。
- 敏捷推崇輕量級工件和快速迭代，這對追蹤個別待辦事項如何映射到更高層次的業務目標提出了挑戰。
- 缺乏清晰的可追溯系統會導致不確定性，例如：「我們是否正在建立符合利害關係人需求的功能？」「測試是否驗證了需求？」「我們是否保證了多個衝刺的全面覆蓋？」

## ☁️ AI 就緒：為何雲端基礎設施將決定下一波的贏家

**Source:** https://dzone.com/articles/ai-readiness-cloud-infrastructure-next-wave

- 雲端和 DevOps 團隊普遍關注的核心問題是：「我們是否已為 AI 做好準備？」
- 本文強調，雲端基礎設施將是決定誰能在下一波 AI 浪潮中脫穎而出的關鍵因素。
- 隨著 AI 應用和技術的快速發展，擁有彈性、可擴展且安全的雲端基礎設施對於企業成功部署和利用 AI 至關重要。

## 📊 模型評估指標解釋

**Source:** https://dzone.com/articles/model-evaluation-metrics-explained

- 衡量機器學習模型的真實性能遠不止於表面上的準確度，所選擇的指標將影響演算法調整，以及模型對使用者、業務和關鍵系統的影響。
- 本文詳細解釋了最實用和廣泛使用的評估指標：準確度 (Accuracy)、精確度 (Precision)、召回率 (Recall)、F1 分數 (F1 Score) 和 ROC-AUC。
- 除了技術定義，文章還討論了這些指標的戰略重要性，即這些數字如何映射到實際結果和業務目標。
- 瞭解如何評估模型成功對於有效的機器學習至關重要，無論是產品發佈還是研究發表。
- 文章還探討了常見的指標陷阱以及如何避免它們。

## 📈 掌握 Fluent Bit：開發者的前 3 個遙測管道輸出插件（第 7 部分）

**Source:** https://dzone.com/articles/top-telemetry-pipeline-output-plugins

- 本文是針對想學習 Cloud Native Computing Foundation (CNCF) 專案 Fluent Bit 的讀者而設計的通用入門指南系列文章的第七部分。
- 該系列每篇文章都針對一個單一主題，提供關於該主題是什麼、為什麼值得探索、從何處入手以及如何實際操作的見解，這些都與 Fluent Bit 專案相關。
- 本部分專注於遙測管道中的輸出插件，旨在幫助開發者了解如何有效地配置 Fluent Bit 來處理和傳輸日誌及指標數據。

## ❌ 測試自動化反模式：當良好實踐成為你最大的敵人

**Source:** https://dzone.com/articles/testing-automation-antipatterns

- 測試自動化是快速高效地獲得對所建構產品信心的基本工具。
- 然而，我們經常遇到一些實踐，這些實踐在短期內看似有益，但長期卻會產生重大問題，這些即是「反模式」。
- 本文旨在探討這些「反模式」，並解釋為何它們會將看似良好的實踐轉變為軟體開發過程中的最大敵人。

## 🔑 為非人類身份設置最小權限原則為何如此關鍵

**Source:** https://dzone.com/articles/least-privilege-non-human-identities

- 攻擊者主要關心洩露的機密是否仍然有效，以及一旦獲得存取權限後授予了哪些權限。
- GitGuardian 2025 年秘密擴散報告指出，在公共領域洩露的 GitLab 和 GitHub API 金鑰中，大多數都被授予了對相關儲存庫的完全讀寫權限。
- 一旦攻擊者控制了儲存庫的存取權限，他們就可以執行各種惡意操作。
- 本文探討了為何團隊未在其專案中遵循最小權限原則 (Principle of Least Privilege, PoLP)，以及如何更好地保護企業免受權限過高的非人類身份 (Non-Human Identities, NHIs) 的侵害。

## 📈 規模化機器學習實驗：高通量指南

**Source:** https://dzone.com/articles/ml-experiments-high-throughput

- A/B 測試對於產品決策至關重要，它將不確定性下的賭注轉化為可衡量的因果學習。
- 透過將使用者隨機分配到控制組和實驗組，可以創建平均上相同的兩組。
- 轉換率、留存率、收入或延遲的任何差異都可以歸因於變更本身，而非季節性、行銷活動或使用者構成的變化。
- 隨機化提供了可靠的反事實 (counterfactual) 依據，使得量化影響成為可能。

## 🛠️ 開發人員的五大 RAD 平台

**Source:** https://dzone.com/articles/top-rad-platforms-for-developers

- 隨著企業旨在更快地交付安全、可擴展的系統並堅持以開發人員為中心的方法，快速應用程式開發 (RAD) 平台的需求日益增長。
- 本文評估了五個受歡迎的 RAD 平台：WaveMaker, OpenXava, OutSystems, Oracle APEX 和 Jmix。
- 文章分析了每個平台的團隊適用性、生產力、安全性、支援、廠商鎖定 (lock-in) 和授權模式，探討了它們的優勢以及入門的難易程度。

## 🐛 Shai-Hulud：自複製蠕蟲入侵 500+ npm 套件

**Source:** https://www.stepsecurity.io/blog/ctrl-tinycolor-and-40-npm-packages-compromised

- Shai-Hulud 蠕蟲在一次前所未有的自傳播供應鏈攻擊中，感染了包括 `@ctrl/tinycolor` 在內的 500 多個 npm 套件。
- 該惡意軟體利用 TruffleHog 收集 AWS/GCP/Azure 雲端憑證。
- 透過 GitHub Actions 後門建立持久性。
- 自動傳播到其他維護者的套件，標誌著 npm 生態系統中首次成功的蠕蟲攻擊。

## ⚠️ s1ngularity：流行的 Nx 建構系統套件被竊取數據惡意軟體入侵

**Source:** https://www.stepsecurity.io/blog/supply-chain-security-alert-popular-nx-build-system-package-compromised-with-data-stealing-malware

- `s1ngularity` 攻擊劫持了 npm 上的 Nx 套件，目的是竊取加密貨幣錢包、GitHub/npm 權杖、SSH 金鑰和環境機密。
- 這是首例記載的惡意軟體利用 AI CLI 工具進行偵察和數據滲透的案例。
- 此事件突顯了在軟體供應鏈中，即使是常用的開發工具也可能成為複雜攻擊的目標。